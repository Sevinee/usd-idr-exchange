# -*- coding: utf-8 -*-
"""forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1stswANnyoPpiHkFn-AnYI6Sp1z1OwLPe
"""

# Load semua yang diperlukan
import pandas as pd
import numpy as np
import joblib

# Data asli (untuk gabung hasil prediksi)
df_final = pd.read_csv("preprocessed_actual_data.csv", parse_dates=["date"], index_col="date")

# Data input ke model
scaled = np.load("scaled_data.npy")

# Scaler untuk inverse transform nanti
scaler = joblib.load("scaler.save")

"""#LSTM"""

# Ubah data time series menjadi supervised learning
def series_to_supervised(data, n_in, n_out, dropnan = True):
    n_vars = 1 if type(data) is list else data.shape[1]
    df = DataFrame(data)
    cols, names = list(), list()
    # input sequence (t-n, ... t-1)
    for i in range(n_in, 0, -1):
        cols.append(df.shift(i))
        names += [('var%d(t-%d)' % (j+1, i)) for j in range(n_vars)]
    # forecast sequence (t, t+1, ... t+n)
    for i in range(0, n_out):
        cols.append(df.shift(-i))
        if i == 0:
            names += [('var%d(t)' % (j+1)) for j in range(n_vars)]
        else:
            names += [('var%d(t+%d)' % (j+1, i)) for j in range(n_vars)]
    # put it all together
    agg = concat(cols, axis = 1)
    agg.columns = names
    # drop rows with NaN values
    if dropnan:
        agg.dropna(inplace = True)
    return agg

# Memastikan semua data bertipe float
values = values.astype('float32')

# DF supervised learning
reframed = series_to_supervised(scaled, 1, 1)
reframed

"""#USD-IDR"""

# Drop kolom yang tidak diperlukan
reframed1 = reframed.drop(reframed.columns[[5, 6, 7]], axis = 1).copy()
reframed1.head()

# Split data
values1 = reframed1.values
train1, test1 = train_test_split(values1, test_size = 0.2, shuffle = False)

# Split menjadi input dan outputs
train_X1, train_y1 = train1[:, :-1], train1[:, -1]
test_X1, test_y1 = test1[:, :-1], test1[:, -1]

# Membentuk ulang input menjadi 3D [samples, timesteps, features]
train_X1 = train_X1.reshape((train_X1.shape[0], 1, train_X1.shape[1]))
test_X1 = test_X1.reshape((test_X1.shape[0], 1, test_X1.shape[1]))
print(train_X1.shape, train_y1.shape, test_X1.shape, test_y1.shape)

# Design LSTM
model1 = Sequential()
model1.add(LSTM(50, input_shape = (train_X1.shape[1], train_X1.shape[2])))
model1.add(Dense(1))
model1.compile(loss = 'mse', optimizer = 'adam')

# Fit LSTM
history1 = model1.fit(train_X1, train_y1, epochs = 250, batch_size = 64, validation_data = (test_X1, test_y1), verbose = 2, shuffle = False)
model1.save('./savedModel.keras')

# Plot history
pyplot.plot(history1.history['loss'], label='train')
pyplot.plot(history1.history['val_loss'], label='test')
pyplot.legend()
pyplot.show()

# Prediksi
yhat1 = model1.predict(test_X1)
test_X1 = test_X1.reshape((test_X1.shape[0], test_X1.shape[2]))

# Invert skala untuk prediksi
prediction1 = concatenate((yhat1, test_X1[:, 1:]), axis = 1)
prediction1 = scaler.inverse_transform(prediction1)
prediction1 = prediction1[:,0]

# DF data test vs prediksi
df_test1 = df_final["usd_idr"][int(len(df_final)*0.8):]
prediction1 = np.array(prediction1)
df_hasil1 = pd.DataFrame()
df_hasil1['Real USD/IDR'] = df_test1
df_hasil1['Prediction'] = prediction1
df_hasil1

# Plot data test vs forecast
plt.figure(figsize = (16,8))
plt.title('Data Test vs Forecast')
plt.ylabel('USD/IDR Rate Exchange')
plt.xlabel('Date')
plt.plot(df_hasil1['Real USD/IDR'])
plt.plot(df_hasil1['Prediction'])
plt.legend(['Data Test', 'Forecast'], loc = 'upper left')
plt.show()

# Plot data test vs forecast
df_hasil11 = df_hasil1.copy()
df_hasil11.reset_index(inplace = True)
plt.figure(figsize = (16,8))
plt.title('Data Test vs Forecast')
plt.ylabel('USD/IDR Rate Exchange')
plt.xlabel('Date')
plt.plot(df_hasil11['Real USD/IDR'])
plt.plot(df_hasil11['Prediction'])
plt.legend(['Data Test', 'Forecast'], loc = 'upper left')
plt.show()

# Kalkulasi MSE
mse = mean_squared_error(df_hasil1["Real USD/IDR"], df_hasil1["Prediction"])

# Kalkulasi RMSE
rmse = np.sqrt(mse)

# Kalkulasi MAE
mae = np.mean(np.abs(df_hasil1["Real USD/IDR"] - df_hasil1["Prediction"]))

# Kalkulasi MAPE
mape = np.mean(np.abs((df_hasil1["Real USD/IDR"] - df_hasil1["Prediction"])/df_hasil1["Real USD/IDR"])) * 100

# Matriks Evaluasi Akurasi Prediksi
data = {'Model': ['LSTM'],
        'RMSE': [rmse],
        'MAE': [mae],
        'MAPE': [mape]}

df_metrics = pd.DataFrame(data)
df_metrics

"""## Crude Oil"""

# Drop kolom yang tidak diperlukan
reframed2 = reframed.drop(reframed.columns[[4, 6, 7]], axis = 1).copy()
print(reframed2.head())

# Split data
values2 = reframed2.values
train2, test2 = train_test_split(values2, test_size = 0.2, shuffle = False)

# Split menjadi input dan outputs
train_X2, train_y2 = train2[:, :-1], train2[:, -1]
test_X2, test_y2 = test2[:, :-1], test2[:, -1]

# Membentuk ulang input menjadi 3D [samples, timesteps, features]
train_X2 = train_X2.reshape((train_X2.shape[0], 1, train_X2.shape[1]))
test_X2 = test_X2.reshape((test_X2.shape[0], 1, test_X2.shape[1]))
print(train_X2.shape, train_y2.shape, test_X2.shape, test_y2.shape)

# Design LSTM
model2 = Sequential()
model2.add(LSTM(50, input_shape = (train_X2.shape[1], train_X2.shape[2])))
model2.add(Dense(1))
model2.compile(loss = 'mse', optimizer = 'adam')

# Fit LSTM
history2 = model2.fit(train_X2, train_y2, epochs = 300, batch_size = 64, validation_data = (test_X2, test_y2), verbose = 2, shuffle = False)
model2.save('./savedModel.keras')

# Plot history
pyplot.plot(history2.history['loss'], label='train')
pyplot.plot(history2.history['val_loss'], label='test')
pyplot.legend()
pyplot.show()

# Prediksi
yhat2 = model2.predict(test_X2)
test_X2 = test_X2.reshape((test_X2.shape[0], test_X2.shape[2]))

# Invert skala untuk prediksi
prediction2 = concatenate((test_X2[:, [0]], yhat2, test_X2[:, 2:]), axis = 1)
prediction2 = scaler.inverse_transform(prediction2)
prediction2 = prediction2[:, 1]

# DF data test vs prediksi
df_test2 = df_final["crude_oil"][int(len(df_final)*0.8):]
prediction2 = np.array(prediction2)
df_hasil2 = pd.DataFrame()
df_hasil2['Real Crude Oil Price'] = df_test2
df_hasil2['Prediction'] = prediction2
df_hasil2

# Plot data test vs forecast
plt.figure(figsize = (16,8))
plt.title('Data Test vs Forecast')
plt.ylabel('Crude Oil Price')
plt.xlabel('Date')
plt.plot(df_hasil2['Real Crude Oil Price'])
plt.plot(df_hasil2['Prediction'])
plt.legend(['Data Test', 'Forecast'], loc = 'upper left')
plt.show()

# Plot data test vs forecast
df_hasil21 = df_hasil2.copy()
df_hasil21.reset_index(inplace = True)
plt.figure(figsize = (16,8))
plt.title('Data Test vs Forecast')
plt.ylabel('Crude Oil Price')
plt.xlabel('Date')
plt.plot(df_hasil21['Real Crude Oil Price'])
plt.plot(df_hasil21['Prediction'])
plt.legend(['Data Test', 'Forecast'], loc = 'upper left')
plt.show()

# Kalkulasi MSE
mse = mean_squared_error(df_hasil2["Real Crude Oil Price"], df_hasil2["Prediction"])

# Kalkulasi RMSE
rmse = np.sqrt(mse)

# Kalkulasi MAE
mae = np.mean(np.abs(df_hasil2["Real Crude Oil Price"] - df_hasil2["Prediction"]))

# Kalkulasi MAPE
mape = np.mean(np.abs((df_hasil2["Real Crude Oil Price"] - df_hasil2["Prediction"])/df_hasil2["Real Crude Oil Price"])) * 100

# Matriks Evaluasi Akurasi Prediksi
data = {'Model': ['LSTM'],
        'RMSE': [rmse],
        'MAE': [mae],
        'MAPE': [mape]}

df_metrics = pd.DataFrame(data)
df_metrics

"""## Gold"""

# Drop kolom yang tidak diperlukan
reframed3 = reframed.drop(reframed.columns[[4, 5, 7]], axis = 1).copy()
print(reframed3.head())

# Split data
values3 = reframed3.values
train3, test3 = train_test_split(values3, test_size = 0.2, shuffle = False)

# Split menjadi input dan outputs
train_X3, train_y3 = train3[:, :-1], train3[:, -1]
test_X3, test_y3 = test3[:, :-1], test3[:, -1]

# Membentuk ulang input menjadi 3D [samples, timesteps, features]
train_X3 = train_X3.reshape((train_X3.shape[0], 1, train_X3.shape[1]))
test_X3 = test_X3.reshape((test_X3.shape[0], 1, test_X3.shape[1]))
print(train_X3.shape, train_y3.shape, test_X3.shape, test_y3.shape)

# Design LSTM
model3 = Sequential()
model3.add(LSTM(50, input_shape = (train_X3.shape[1], train_X3.shape[2])))
model3.add(Dense(1))
model3.compile(loss = 'mse', optimizer = 'adam')

# Fit LSTM
history3 = model3.fit(train_X3, train_y3, epochs = 300, batch_size = 64, validation_data = (test_X3, test_y3), verbose = 2, shuffle = False)
model3.save('./savedModel.keras')

# Plot history
pyplot.plot(history3.history['loss'], label='train')
pyplot.plot(history3.history['val_loss'], label='test')
pyplot.legend()
pyplot.show()

# Prediksi
yhat3 = model3.predict(test_X3)
test_X3 = test_X3.reshape((test_X3.shape[0], test_X3.shape[2]))

# Invert skala untuk prediksi
prediction3 = concatenate((test_X3[:, :2], yhat3, test_X3[:, [3]]), axis = 1)
prediction3 = scaler.inverse_transform(prediction3)
prediction3 = prediction3[:, 2]

# DF data test vs prediksi
df_test3 = df_final["gold"][int(len(df_final)*0.8):]
prediction3 = np.array(prediction3)
df_hasil3 = pd.DataFrame()
df_hasil3['Real Gold Price'] = df_test3
df_hasil3['Prediction'] = prediction3
df_hasil3

# Plot data test vs forecast
plt.figure(figsize = (16,8))
plt.title('Data Test vs Forecast')
plt.ylabel('Gold Price')
plt.xlabel('Date')
plt.plot(df_hasil3['Real Gold Price'])
plt.plot(df_hasil3['Prediction'])
plt.legend(['Data Test', 'Forecast'], loc = 'upper left')
plt.show()

df_hasil31 = df_hasil3.copy()
df_hasil31.reset_index(inplace = True)
plt.figure(figsize = (16,8))
plt.title('Data Test vs Forecast')
plt.ylabel('Gold Price')
plt.xlabel('Date')
plt.plot(df_hasil31['Real Gold Price'])
plt.plot(df_hasil31['Prediction'])
plt.legend(['Data Test', 'Forecast'], loc = 'upper left')
plt.show()

# Kalkulasi MSE
mse = mean_squared_error(df_hasil3["Real Gold Price"], df_hasil3["Prediction"])

# Kalkulasi RMSE
rmse = np.sqrt(mse)

# Kalkulasi MAE
mae = np.mean(np.abs(df_hasil3["Real Gold Price"] - df_hasil3["Prediction"]))

# Kalkulasi MAPE
mape = np.mean(np.abs((df_hasil3["Real Gold Price"] - df_hasil3["Prediction"])/df_hasil3["Prediction"])) * 100

# Matriks Evaluasi Akurasi Prediksi
data = {'Model': ['LSTM'],
        'RMSE': [rmse],
        'MAE': [mae],
        'MAPE': [mape]}

df_metrics = pd.DataFrame(data)
df_metrics

"""## Inflation"""

# Drop kolom yang tidak diperlukan
reframed4 = reframed.drop(reframed.columns[[4, 5, 6]], axis = 1).copy()
print(reframed4.head())

# Split data
values4 = reframed4.values
train4, test4 = train_test_split(values4, test_size = 0.2, shuffle = False)

# Split menjadi input dan outputs
train_X4, train_y4 = train4[:, :-1], train4[:, -1]
test_X4, test_y4 = test4[:, :-1], test4[:, -1]

# Membentuk ulang input menjadi 3D [samples, timesteps, features]
train_X4 = train_X4.reshape((train_X4.shape[0], 1, train_X4.shape[1]))
test_X4 = test_X4.reshape((test_X4.shape[0], 1, test_X4.shape[1]))
print(train_X4.shape, train_y4.shape, test_X4.shape, test_y4.shape)

# Design LSTM
model4 = Sequential()
model4.add(LSTM(50, input_shape = (train_X4.shape[1], train_X4.shape[2])))
model4.add(Dense(1))
model4.compile(loss = 'mse', optimizer = 'adam')

# Fit LSTM
history4 = model4.fit(train_X4, train_y4, epochs = 10, batch_size = 16, validation_data = (test_X4, test_X4), verbose = 2, shuffle = False)
model4.save('./savedModel.keras')

# Plot history
pyplot.plot(history4.history['loss'], label='train')
pyplot.plot(history4.history['val_loss'], label='test')
pyplot.legend()
pyplot.show()

# Prediksi
yhat4 = model4.predict(test_X4)
test_X4 = test_X4.reshape((test_X4.shape[0], test_X4.shape[2]))

# Invert skala untuk prediksi
prediction4 = concatenate((test_X4[:, :3], yhat4), axis = 1)
prediction4 = scaler.inverse_transform(prediction4)
prediction4 = prediction4[:, 3]

# DF data test vs prediksi
df_test4 = df_final["inflation"][int(len(df_final)*0.8):]
prediction4 = np.array(prediction4)
df_hasil4 = pd.DataFrame()
df_hasil4['Real Inflation'] = df_test4
df_hasil4['Prediction'] = prediction4
df_hasil4

# Plot data test vs forecast
plt.figure(figsize = (16,8))
plt.title('Data Test vs Forecast')
plt.ylabel('Gold Inflation')
plt.xlabel('Date')
plt.plot(df_hasil4['Real Inflation'])
plt.plot(df_hasil4['Prediction'])
plt.legend(['Data Test', 'Forecast'], loc = 'upper left')
plt.show()

df_hasil41 = df_hasil4.copy()
df_hasil41.reset_index(inplace = True)
plt.figure(figsize = (16,8))
plt.title('Data Test vs Forecast')
plt.ylabel('Inflation')
plt.xlabel('Date')
plt.plot(df_hasil41['Real Inflation'])
plt.plot(df_hasil41['Prediction'])
plt.legend(['Data Test', 'Forecast'], loc = 'upper left')
plt.show()

# Kalkulasi MSE
mse = mean_squared_error(df_hasil4["Real Inflation"], df_hasil4["Prediction"])

# Kalkulasi RMSE
rmse = np.sqrt(mse)

# Kalkulasi MAE
mae = np.mean(np.abs(df_hasil4["Real Inflation"] - df_hasil4["Prediction"]))

# Kalkulasi MAPE
mape = np.mean(np.abs((df_hasil4["Real Inflation"] - df_hasil4["Prediction"])/df_hasil4["Real Inflation"])) * 100

# Matriks Evaluasi Akurasi Prediksi
data = {'Model': ['LSTM'],
        'RMSE': [rmse],
        'MAE': [mae],
        'MAPE': [mape]}

df_metrics = pd.DataFrame(data)
df_metrics

"""# Forecast"""

# Forecast 7 hari ke depan
forecast_day = 7
last1_data = df_final[-1:].values

# Normalisasi input
forecast_input_scaled = scaler.transform(last1_data)

# inisialisasi input awal
predictions_scaled = []
current_input = forecast_input_scaled

for _ in range(forecast_day):
    # Bentuk input jadi (1, 1, 4) karena 1 timestep, 4 fitur
    reshaped_input = current_input.reshape(1, 1, 4)

    # Prediksi masing-masing variabel
    next_scaled1 = model1.predict(reshaped_input, verbose=0)[0][0]
    next_scaled2 = model2.predict(reshaped_input, verbose=0)[0][0]
    next_scaled3 = model3.predict(reshaped_input, verbose=0)[0][0]
    next_scaled4 = model4.predict(reshaped_input, verbose=0)[0][0]

    # Gabungkan prediksi jadi satu array [1, 4]
    next_scaled = np.array([[next_scaled1, next_scaled2, next_scaled3, next_scaled4]])

    # Simpan hasil prediksi
    predictions_scaled.append(next_scaled[0])

    # Gunakan prediksi ini sebagai input untuk langkah berikutnya
    current_input = next_scaled

# Konversi ke array dan inverse transform
predictions_scaled = np.array(predictions_scaled)
forecast_7day = scaler.inverse_transform(predictions_scaled)

# Tampilkan hasil prediksi
for i, nilai in enumerate(forecast_7day):
    print(f"Hari ke-{i+1}: {nilai}")

# Forecast
df_forecast = pd.DataFrame(forecast_7day[:, 0], columns = ['Exchange Rate USD/IDR'])

# Tentukan tanggal mulai berdasarkan data historis terakhir
start_date_forecast = df_exchange.index[-1] + pd.Timedelta(days=1)

# Buat rentang tanggal hanya hari kerja (weekday < 5)
forecast_dates = pd.date_range(start=start_date_forecast, periods=len(df_forecast)*2, freq='D')
forecast_dates = [d for d in forecast_dates if d.weekday() < 5][:len(df_forecast)]

# Masukkan tanggal ke dataframe dan set index
df_forecast['date'] = forecast_dates
df_forecast.set_index('date', inplace=True)

# Gabungkan hasil forecast dengan data awal
df_exchange = df_final.copy()
df_exchange = df_exchange.drop(df_exchange.columns[[1, 2, 3]], axis = 1)
df_exchange = df_exchange.rename(columns={'usd_idr': 'Exchange Rate USD/IDR'})
data_final = pd.concat([df_exchange, df_forecast], axis = 0)
data_final.tail(10)

# Gabungkan hasil forecast dengan 1 data asli terakhir
df1 = pd.concat([df_exchange.tail(1), df_forecast], axis = 0)
df1

# Tambahkan ke plot harga historis
plt.figure(figsize = (10, 6))
plt.plot(df_final['usd_idr'], label = 'Exchange Rate')
plt.plot(df_hasil1["Prediction"], label = "Forecast")

# Tambahkan prediksi ke grafik
plt.plot(df1, label = '7-Day Forecast', color = 'green')
plt.legend(loc = "upper left")
plt.title("Forecast Exchange Rate USD/IDR 7 days ahead")
plt.xlabel("Date")
plt.ylabel("Exchange Rate")
plt.grid()
plt.show()

# Plot 30 hari terakhir + prediksi
plt.figure(figsize = (15, 6))
plt.plot(df_exchange.tail(30), label = 'Exchange Rate')
plt.plot(df1, label = "Forecast")
plt.xlabel("Date")
plt.ylabel("Exchange Rate")
plt.legend(loc = "upper left")
plt.grid()
plt.show()

# Simpan data aktual
df_exchange.rename(columns={"Exchange Rate USD/IDR": "usd_idr"}).to_csv("usd_idr_actual.csv", index_label="date")

# Simpan prediksi terbaru
df_forecast.rename(columns={"Exchange Rate USD/IDR": "predicted_usd_idr"}).to_csv("usd_idr_pred_latest.csv", index_label="date")

# Simpan prediksi kemarin (semua kecuali baris terakhir)
df_forecast.iloc[:-1].rename(columns={"Exchange Rate USD/IDR": "predicted_usd_idr"}).to_csv("usd_idr_pred_yesterday.csv", index_label="date")